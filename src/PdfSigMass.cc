/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 
#include "RooFit.h"

#include "Riostream.h" 

#include "PdfSigMass.h" 
#include "GBRMath.h"

#include "RooDataHist.h"
#include "TMatrixDSym.h"
#include "RooFitResult.h"
ClassImp(PdfSigMass) 

using namespace RooFit;

PdfSigMass::PdfSigMass(const char *name, const char *title, 
		     RooAbsReal& _m,
         	     RooAbsReal& _mean_rt  ,
         	     RooAbsReal& _sigma_rt1,
         	     RooAbsReal& _alpha_rt1,
         	     RooAbsReal& _alpha_rt2,
         	     RooAbsReal& _n_rt1    ,
         	     RooAbsReal& _n_rt2    ,
         	     RooAbsReal& _mean_wt  ,
         	     RooAbsReal& _sigma_wt1,
         	     RooAbsReal& _alpha_wt1,
         	     RooAbsReal& _alpha_wt2,
         	     RooAbsReal& _n_wt1    ,
         	     RooAbsReal& _n_wt2    ,
		     RooAbsReal& _mFrac    ,
		     RooAbsReal& _rtMassTerm,
		     RooAbsReal& _wtMassTerm
		     ) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  mean_rt("mean_rt"  , "mean_rt"  ,this,_mean_rt  ),
  sigma_rt1("sigma_rt1" , "sigma_rt1" ,this,_sigma_rt1 ),
  alpha_rt1("alpha_rt1", "alpha_rt1",this,_alpha_rt1),
  alpha_rt2("alpha_rt2", "alpha_rt2",this,_alpha_rt2),
  n_rt1("n_rt1"    , "n_rt1"    ,this,_n_rt1    ),
  n_rt2("n_rt2"    , "n_rt2"    ,this,_n_rt2    ),
  mean_wt("mean_wt"  , "mean_wt"  ,this,_mean_wt  ),
  sigma_wt1("sigma_wt1" , "sigma_wt1" ,this,_sigma_wt1 ),
  alpha_wt1("alpha_wt1", "alpha_wt1",this,_alpha_wt1),
  alpha_wt2("alpha_wt2", "alpha_wt2",this,_alpha_wt2),
  n_wt1("n_wt1"    , "n_wt1"    ,this,_n_wt1    ),
  n_wt2("n_wt2"    , "n_wt2"    ,this,_n_wt2    ),
  mFrac("mFrac","mFrac",this,_mFrac),
  rtMassTerm("rtMassTerm","rtMassTerm",this,_rtMassTerm),
//   rtMassTerm("rtMassTerm","rtMassTerm",this,_rtMassTerm, kFALSE, kFALSE)
  wtMassTerm("wtMassTerm","wtMassTerm",this,_wtMassTerm)
{
}

PdfSigMass::PdfSigMass(const char *name, const char *title, 
		     RooAbsReal& _m,
         	     RooAbsReal& _mean_rt  ,
         	     RooAbsReal& _sigma_rt1,
         	     RooAbsReal& _sigma_rt2 ,
         	     RooAbsReal& _alpha_rt1,
         	     RooAbsReal& _alpha_rt2,
         	     RooAbsReal& _n_rt1    ,
         	     RooAbsReal& _n_rt2    ,
         	     RooAbsReal& _f1rt  ,
         	     RooAbsReal& _mean_wt  ,
         	     RooAbsReal& _sigma_wt1,
         	     RooAbsReal& _alpha_wt1,
         	     RooAbsReal& _alpha_wt2,
         	     RooAbsReal& _n_wt1    ,
         	     RooAbsReal& _n_wt2    ,
		     RooAbsReal& _mFrac,
		     RooAbsReal& _rtMassTerm,
		     RooAbsReal& _wtMassTerm
		     ) :
  RooAbsPdf(name,title), 
  m("m","m",this,_m),
  mean_rt("mean_rt", "mean_rt"  ,this,_mean_rt),
  sigma_rt1("sigma_rt1", "sigma_rt1" ,this,_sigma_rt1),
  sigma_rt2("sigma_rt2", "sigma_rt2" ,this,_sigma_rt2),
  alpha_rt1("alpha_rt1", "alpha_rt1",this,_alpha_rt1),
  alpha_rt2("alpha_rt2", "alpha_rt2",this,_alpha_rt2),
  n_rt1("n_rt1", "n_rt1",this,_n_rt1),
  n_rt2("n_rt2", "n_rt2",this,_n_rt2),
  f1rt("f1rt", "f1rt",this,_f1rt),
  mean_wt("mean_wt"  , "mean_wt"  ,this,_mean_wt  ),
  sigma_wt1("sigma_wt1" , "sigma_wt1" ,this,_sigma_wt1 ),
  alpha_wt1("alpha_wt1", "alpha_wt1",this,_alpha_wt1),
  alpha_wt2("alpha_wt2", "alpha_wt2",this,_alpha_wt2),
  n_wt1("n_wt1"    , "n_wt1"    ,this,_n_wt1    ),
  n_wt2("n_wt2"    , "n_wt2"    ,this,_n_wt2    ),
  mFrac("mFrac","mFrac",this,_mFrac),
  rtMassTerm("rtMassTerm","rtMassTerm",this,_rtMassTerm),
  wtMassTerm("wtMassTerm","wtMassTerm",this,_wtMassTerm)
{
}



PdfSigMass::PdfSigMass(const PdfSigMass& other, const char* name) :  
  RooAbsPdf(other,name), 
  m("m",this,other.m),
  mean_rt("mean_rt",this,other.mean_rt),
  sigma_rt1("sigma_rt1",this,other.sigma_rt1),
  sigma_rt2("sigma_rt2",this,other.sigma_rt2),
  alpha_rt1("alpha_rt1",this,other.alpha_rt1),
  alpha_rt2("alpha_rt2",this,other.alpha_rt2),
  n_rt1("n_rt1",this,other.n_rt1),
  n_rt2("n_rt2",this,other.n_rt2),
  f1rt("f1rt",this,other.f1rt),
  mean_wt("mean_wt",this,other.mean_wt),
  sigma_wt1("sigma_wt1",this,other.sigma_wt1),
  alpha_wt1("alpha_wt1",this,other.alpha_wt1),
  alpha_wt2("alpha_wt2",this,other.alpha_wt2),
  n_wt1("n_wt1",this,other.n_wt1),
  n_wt2("n_wt2",this,other.n_wt2),
  mFrac("mFrac",this,other.mFrac),
  rtMassTerm("rtMassTerm", this, other.rtMassTerm),
  wtMassTerm("wtMassTerm", this, other.wtMassTerm)
{
}



Double_t PdfSigMass::evaluate() const 
{

//   std::cout << m << "  " << sigma_rt2 << "  " << f1rt << std::endl;
//   rtMassTerm.arg().getVariables()->Print("v");
  
  //test sara
//   RooAbsReal & marg = (RooAbsReal&)m.arg();
//   RooArgSet massSet (marg);
//   std::cout << ((RooAbsPdf&)(rtMassTerm.arg())).getVal() << std::endl;
  double mCT = ((RooAbsPdf&)(rtMassTerm.arg())).getVal();
  double mWT = ((RooAbsPdf&)(wtMassTerm.arg())).getVal();
  
//   double theIntegral = ((RooAbsPdf&)(rtMassTerm.arg())).analyticalIntegral(1, "null");
//   std::cout <<  theIntegral << std::endl;
  
//   RooDataHist* data = ((RooAbsPdf&)(rtMassTerm.arg())).generateBinned(RooArgSet(massSet),ExpectedData());
//   RooFitResult* res = ((RooAbsPdf&)(rtMassTerm.arg())).fitTo(*data, Save(),PrintLevel(-1),Minos(kFALSE),SumW2Error(kFALSE));
//   double ret = ((PdfCBShape&)(rtMassTerm.arg()))->getVal();
//   double ret = ((RooAbsReal*) rtMassTerm.absArg())->getVal();
  
//   RooAbsReal xarg = m.arg() ;
//   RooArgSet massSet (xarg);
//   RooSetProxy massSetProxy (m);
//   RooArgSet massSet ((RooAbsReal*) m.absArg() );
//   double sara = rtMassTermPdf()->createIntegral(massSet, RooFit::Range("rangename"));
//   std::cout<<"pdfSigMass: " << m <<  ": " << rtMassValue << " : " << wtMassValue  << std::endl;
  
//   double ret = (effCValue  * rtMassValue + mFrac * effWValue * wtMassValue) * penalty);
//   return sara;


//   PdfCBShape* rt = new PdfCBShape("cbs", "Crystal Ball shape", 
//                                   *(RooAbsReal*)m.absArg(), 
//                                    *(RooAbsReal*)mean_rt.absArg(), 
//                                    *(RooAbsReal*)width.absArg(), 
//                                    *(RooAbsReal*)alpha_rt1.absArg(), 
//                                    *(RooAbsReal*)n_rt1.absArg(), 
//                                    *(RooAbsReal*)alpha_rt2.absArg(), 
//                                    *(RooAbsReal*)n_rt2.absArg());
   
//   std::cout<<"pdfSigMass: " << m <<  ": " << myrtMassTermPdf()->eval() << " : " << sara  << std::endl;

//    return mCT ;
   return mCT + (1-mFrac)*mWT;

}


// Int_t PdfSigMass::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
// {
//   if ( matchArgs(allVars,analVars,m) ){
//       return 1 ;
//   }
//   return 0 ;
// }
// 
// Double_t PdfSigMass::analyticalIntegral(Int_t code, const char* rangeName) const
// {
//   assert(code>0 && code<2) ;
//   double theIntegralRT = ((RooAbsPdf&)(rtMassTerm.arg())).analyticalIntegral(1, "");
// 
//   double theIntegralWT = ((RooAbsPdf&)(wtMassTerm.arg())).analyticalIntegral(1, "");
// //   std::cout <<  theIntegralRT + (1-mFrac)*theIntegralWT << std::endl;
// 
// 
// // // // //     //   double sara = rtMassTermPdf()->createIntegral(m, rangeName);
// // // // //     //   double rtMass = rtMassTerm.analyticalIntegral();
// // // // //     //   RooAbsReal& marg = m.absArg() ; 
// // // // //     RooAbsReal & marg = (RooAbsReal&)m.arg();
// // // // //     
// // // // //     RooAbsReal & rtMass = (RooAbsReal&)rtMassTerm.arg();
// // // // //     double rtMassIntegral = ((RooAbsReal* )rtMass.createIntegral(marg, RooFit::NormSet(marg)))->getVal();
// // // // //     
// // // // //     RooAbsReal & wtMass = (RooAbsReal&)wtMassTerm.arg();
// // // // //     double wtMassIntegral = ((RooAbsReal* )wtMass.createIntegral(marg, RooFit::NormSet(marg)))->getVal();
// // // // //     theIntegral = rtMassIntegral + mFrac*wtMassIntegral  ;
// // // // //   }
// // // // //   
// // // // //   
// // // // //   
// //   return theIntegralRT ;
//   return theIntegralRT + (1-mFrac)*theIntegralWT;
// }
