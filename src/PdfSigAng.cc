/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "PdfSigAng.h" 

ClassImp(PdfSigAng) 

PdfSigAng::PdfSigAng(const char *name, const char *title, 
		     RooAbsReal& _ctK,
		     RooAbsReal& _ctL,
		     RooAbsReal& _phi,
		     RooAbsReal& _Fl,
		     RooAbsReal& _P1,
		     RooAbsReal& _P2,
		     RooAbsReal& _P3,
		     RooAbsReal& _P4p,
		     RooAbsReal& _P5p,
		     RooAbsReal& _P6p,
		     RooAbsReal& _P8p,
		     RooAbsReal& _mFrac,
		     RooAbsReal& _EffC,
		     RooAbsReal& _EffW,
		     std::vector<double> _intCPart,
		     std::vector<double> _intWPart) :
  RooAbsPdf(name,title), 
  ctK("ctK","ctK",this,_ctK),
  ctL("ctL","ctL",this,_ctL),
  phi("phi","phi",this,_phi),
  Fl("Fl","Fl",this,_Fl),
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  P4p("P4p","P4p",this,_P4p),
  P5p("P5p","P5p",this,_P5p),
  P6p("P6p","P6p",this,_P6p),
  P8p("P8p","P8p",this,_P8p),
  mFrac("mFrac","mFrac",this,_mFrac),
  EffC("EffC","corr-tag efficiency",this,_EffC),
  EffW("EffW","wrong-tag efficiency",this,_EffW),
  intCPart(_intCPart),
  intWPart(_intWPart)
{
}


PdfSigAng::PdfSigAng(const PdfSigAng& other, const char* name) :  
  RooAbsPdf(other,name), 
  ctK("ctK",this,other.ctK),
  ctL("ctL",this,other.ctL),
  phi("phi",this,other.phi),
  Fl("Fl",this,other.Fl),
  P1("P1",this,other.P1),
  P2("P2",this,other.P2),
  P3("P3",this,other.P3),
  P4p("P4p",this,other.P4p),
  P5p("P5p",this,other.P5p),
  P6p("P6p",this,other.P6p),
  P8p("P8p",this,other.P8p),
  mFrac("mFrac",this,other.mFrac),
  EffC("EffC",this,other.EffC),
  EffW("EffW",this,other.EffW),
  intCPart(other.intCPart),
  intWPart(other.intWPart)
{
}



Double_t PdfSigAng::evaluate() const 
{

  double decCT = ( 0.75 * (1-Fl) * (1-ctK*ctK) +
		   Fl * ctK*ctK +
		   ( 0.25 * (1-Fl) * (1-ctK*ctK) - Fl * ctK*ctK ) * ( 2 * ctL*ctL -1 ) +
		   0.5 * P1 * (1-Fl) * (1-ctK*ctK) * (1-ctL*ctL) * cos(2*phi) +
		   2 * cos(phi) * ctK * sqrt(Fl * (1-Fl) * (1-ctK*ctK)) * ( P4p * ctL * sqrt(1-ctL*ctL) + P5p * sqrt(1-ctL*ctL) ) +
		   2 * sin(phi) * ctK * sqrt(Fl * (1-Fl) * (1-ctK*ctK)) * ( P8p * ctL * sqrt(1-ctL*ctL) - P6p * sqrt(1-ctL*ctL) ) +
		   2 * P2 * (1-Fl) * (1-ctK*ctK) * ctL -
		   P3 * (1-Fl) * (1-ctK*ctK) * (1-ctL*ctL) * sin(2*phi) );
  // if ( decCT<1e-55 ) return 1e-55;

  double decWT = ( 0.75 * (1-Fl) * (1-ctK*ctK) +
		   Fl * ctK*ctK +
		   ( 0.25 * (1-Fl) * (1-ctK*ctK) - Fl * ctK*ctK ) * ( 2 * ctL*ctL -1 ) +
		   0.5 * P1 * (1-Fl) * (1-ctK*ctK) * (1-ctL*ctL) * cos(2*phi) -
		   2 * cos(phi) * ctK * sqrt(Fl * (1-Fl) * (1-ctK*ctK)) * ( -1. * P4p * ctL * sqrt(1-ctL*ctL) + P5p * sqrt(1-ctL*ctL) ) +
		   2 * sin(phi) * ctK * sqrt(Fl * (1-Fl) * (1-ctK*ctK)) * ( -1. * P8p * ctL * sqrt(1-ctL*ctL) - P6p * sqrt(1-ctL*ctL) ) -
		   2 * P2 * (1-Fl) * (1-ctK*ctK) * ctL +
		   P3 * (1-Fl) * (1-ctK*ctK) * (1-ctL*ctL) * sin(2*phi) );
  // if ( decWT<1e-55 ) return 1e-55;

  double effCValue = effCVal()->getVal();
  if (effCValue<0)  std::cout<<"ERROR! NEGATIVE CT EFFICIENCY SPOTTED AT ("<<ctK<<","<<ctL<<","<<phi<<"): "<<effCValue<<std::endl;
  if (effCValue==0) std::cout<<"ERROR! ZERO CT EFFICIENCY SPOTTED AT ("    <<ctK<<","<<ctL<<","<<phi<<"): "<<effCValue<<std::endl;

  double effWValue = effWVal()->getVal();
  if (effWValue<0)  std::cout<<"ERROR! NEGATIVE WT EFFICIENCY SPOTTED AT ("<<ctK<<","<<ctL<<","<<phi<<"): "<<effWValue<<std::endl;
  if (effWValue==0) std::cout<<"ERROR! ZERO WT EFFICIENCY SPOTTED AT ("    <<ctK<<","<<ctL<<","<<phi<<"): "<<effWValue<<std::endl;

  // std::cout<<"->"<<effCValue<<"*"<<decCT<<" + "<<mFrac<<"*"<<effWValue<<"*"<<decWT<<std::endl;
  return (9./(32 * 3.14159265) * (effCValue * decCT + mFrac * effWValue * decWT) * PdfSigAng::penalty(P1, P2, P3, P4p, P5p, P6p, P8p) );

}

Double_t PdfSigAng::penalty(double P1, double P2, double P3, double P4p, double P5p, double P6p, double P8p) const{

  // Physical Region: should be < 0
  double ctL4phi1 = P4p*P4p + P5p*P5p + P6p*P6p + P8p*P8p - 2 + 2*fabs( 2*P2 - P4p*P5p +P6p*P8p );
  // Physical Region: should be < 0
  double ctK2 = P1*P1 + 4*P2*P2 + 4*P3*P3 -1;
  // Physical Region: should be < 0
  double ctL2phi1 = P5p*P5p*(1-P1) + P6p*P6p*(1+P1) - 4*P3*P5p*P6p - 1 + P1*P1 + 4*P3*P3;
  // Physical Region: should be < 0
  double ctL2phi2 = P6p*P6p - 1 + P1;
  // Physical Region: should be < 0
  double ctL2phi3 = P5p*P5p - 1 - P1;

  double x = TMath::Max(ctL4phi1, ctK2);
  x = TMath::Max(x, ctL2phi1);
  x = TMath::Max(x, ctL2phi2);
  x = TMath::Max(x, ctL2phi3);
  double penalty1 = 1.;
  penalty1 = x > 0 ? exp(-1000*x*x*x*x) : 1.;
  if (penalty1 < 1.E-10)  penalty1 = 1.E-10;

  // at least one of the three should be > 0
  double a0 = 1 - P1*P1 - P6p*P6p*(1+P1) - P8p*P8p*(1-P1) - 4*P2*P2 - 4*P2*P6p*P8p; 
  double a4 = 1 - P1*P1 - P4p*P4p*(1+P1) - P5p*P5p*(1-P1) - 4*P2*P2 + 4*P2*P4p*P5p; 
  double a1 = 4*P3*P8p*P8p - 4*P3*P6p*P6p - 8*P1*P3 + 2*P5p*P6p*(1+P1) - 2*P4p*P8p*(1-P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
  double a3 = 4*P3*P4p*P4p - 4*P3*P5p*P5p + 8*P1*P3 + 2*P5p*P6p*(1-P1) - 2*P4p*P8p*(1+P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
  double a2 = 2 + 2*P1*P1 - 8*P2*P2 - 16*P3*P3 - (P4p*P4p+P6p*P6p)*(1-P1) - (P5p*P5p+P8p*P8p)*(1+P1) + 4*P2*P4p*P5p - 4*P2*P6p*P8p + 8*P3*P4p*P8p + 8*P3*P5p*P6p;
  double b0 = P8p*P8p - 1 - P1 + 2*P2 + P6p*P8p; 
  double b2 = P4p*P4p - 1 + P1 + 2*P2 - P4p*P5p; 
  double b1 = P4p*P8p - 2*P3 + 0.5 * ( P4p*P6p - P5p*P8p );
  double c0 = P8p*P8p - 1 - P1 - 2*P2 - P6p*P8p; 
  double c2 = P4p*P4p - 1 + P1 - 2*P2 + P4p*P5p; 
  double c1 = P4p*P8p - 2*P3 - 0.5 * ( P4p*P6p - P5p*P8p );
  
  int nSteps = 100;
  int halfSteps = nSteps/2;
  double phi, sin2, sincos, cos2;
  double ctL1, ctL5p, ctL5m;
  double tmp_y = 0;
  double y = 0;
  for (int step = 0; step < nSteps+1; ++step) {
    phi = 3.14159 * step / nSteps;
    sin2 = sin(phi)*sin(phi);
    sincos = sin(phi)*cos(phi);
    cos2 = cos(phi)*cos(phi);

    ctL5p = b0*sin2 + b1*sincos + b2*cos2;
    if ( ctL5p >= 0 ) continue;
    ctL5m = c0*sin2 + c1*sincos + c2*cos2;
    if ( ctL5m >= 0 ) continue;
    ctL1 = a0*sin2*sin2 + a1*sin2*sincos + a2*sin2*cos2 + a3*sincos*cos2 + a4*cos2*cos2;
    if ( ctL1 >= 0 ) continue;

    tmp_y = TMath::Min(ctL5p, TMath::Min( ctL5m, ctL1));
    if (tmp_y < y) y = tmp_y; 
  }  

  double penalty2 = 1;
  penalty2 = y < 0 ? exp(-1000*y*y*y*y) : 1.;
  if (penalty2 < 1.E-10)  penalty2 = 1.E-10;
//   if (penalty1 != 1 || penalty2 != 1)
//     std::cout << "sara: " << penalty1 << "  " << penalty2 << "  x = " << x << " and y = " << y << std::endl;
  return TMath::Min(penalty1, penalty2);

} 



namespace {
  Bool_t fullRangeCosT(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for cosTheta variables
    return range == 0 || strlen(range) == 0
      ? std::fabs(x.min() + 1.) < 1.e-5 && std::fabs(x.max() - 1.) < 1.e-5
      : std::fabs(x.min(range) + 1.) < 1.e-5 && std::fabs(x.max(range) - 1.) < 1.e-5;
  }
  Bool_t fullRangePhi(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for phi variable
    return range == 0 || strlen(range) == 0
      ? std::fabs(x.min() + TMath::Pi()) < 1.e-3 && std::fabs(x.max() - TMath::Pi()) < 1.e-3
      : std::fabs(x.min(range) + TMath::Pi()) < 1.e-3 && std::fabs(x.max(range) - TMath::Pi()) < 1.e-3;
  }
}

Int_t PdfSigAng::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{
  // use pre-computed integrals for the integration over all the three variables
  // after checking that integrals are in place
  if ( intCPart.size()<1 || intCPart[0]==0 || intWPart.size()<1 || intWPart[0]==0 )
    return 0 ;
  if ( matchArgs(allVars,analVars,ctK,ctL,phi) )
    if ( fullRangeCosT(ctK,rangeName) && fullRangeCosT(ctL,rangeName) && fullRangePhi(phi,rangeName) )
      return 1 ;

  // the lack of analytical integral for the subsets of angular variables does not slow down the fit
  // since only the complete integration is used there
  // if one wants to speed up also the PDF projection for plotting, the other analytical integrals can be computed
  // but it seems a huge effort to me
  return 0 ;

}

Double_t PdfSigAng::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code>0 && code<2) ;

  // use the pre-computed integrals from histogram
  Double_t retCT =  9./(32*3.14159265) * (
					  0.75*(1-Fl)              * intCPart[0]
					  + Fl                     * intCPart[1]
					  + 0.25*(1-Fl)            * intCPart[2]
					  - Fl                     * intCPart[3]
					  + 0.5*P1*(1-Fl)          * intCPart[4]
					  + 0.5*sqrt(Fl-Fl*Fl)*P4p * intCPart[5]
					  + sqrt(Fl-Fl*Fl)*P5p     * intCPart[6]
					  - sqrt(Fl-Fl*Fl)*P6p     * intCPart[7]
					  + 0.5*sqrt(Fl-Fl*Fl)*P8p * intCPart[8]
					  + 2*(1-Fl)*P2            * intCPart[9]
					  - P3*(1-Fl)              * intCPart[10]
					  );
  
  Double_t retWT =  9./(32*3.14159265) * (
					  0.75*(1-Fl)              * intWPart[0]
					  + Fl                     * intWPart[1]
					  + 0.25*(1-Fl)            * intWPart[2]
					  - Fl                     * intWPart[3]
					  + 0.5*P1*(1-Fl)          * intWPart[4]
					  + 0.5*sqrt(Fl-Fl*Fl)*P4p * intWPart[5]
					  - sqrt(Fl-Fl*Fl)*P5p     * intWPart[6]
					  - sqrt(Fl-Fl*Fl)*P6p     * intWPart[7]
					  - 0.5*sqrt(Fl-Fl*Fl)*P8p * intWPart[8]
					  - 2*(1-Fl)*P2            * intWPart[9]
					  + P3*(1-Fl)              * intWPart[10]
					  );


  if (retCT<=0) {
    if (retCT<0) std::cout<<"ERROR! Negative ct pdf integral, fake value returned"<<std::endl;
    else std::cout<<"ERROR! Null ct pdf integral, fake value returned"<<std::endl;
    return 1e-55;
  }
  if (retWT<=0) {
    if (retWT<0) std::cout<<"ERROR! Negative wt pdf integral, fake value returned"<<std::endl;
    else std::cout<<"ERROR! Null wt pdf integral, fake value returned"<<std::endl;
    return 1e-55;
  }
 
  return ((retCT+mFrac*retWT)* PdfSigAng::penalty(P1, P2, P3, P4p, P5p, P6p, P8p)) ;

}
