/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "BoundDist.h" 

ClassImp(BoundDist) 

BoundDist::BoundDist(const char *name, const char *title, 
		     RooAbsReal& _P1,
		     RooAbsReal& _P2,
		     RooAbsReal& _P3,
		     RooAbsReal& _P4p,
		     RooAbsReal& _P5p,
		     RooAbsReal& _P6p,
		     RooAbsReal& _P8p,
		     bool _useCTL4,
		     double _useCTL15,
		     bool _verbose) :
RooAbsReal(name,title), 
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  P4p("P4p","P4p",this,_P4p),
  P5p("P5p","P5p",this,_P5p),
  P6p("P6p","P6p",this,_P6p),
  P8p("P8p","P8p",this,_P8p)
{

  useCTL4 = _useCTL4;
  useCTL15 = _useCTL15;

  verbose = _verbose;

}


BoundDist::BoundDist(const BoundDist& other, const char* name) :  
  RooAbsReal(other,name), 
  P1("P1",this,other.P1),
  P2("P2",this,other.P2),
  P3("P3",this,other.P3),
  P4p("P4p",this,other.P4p),
  P5p("P5p",this,other.P5p),
  P6p("P6p",this,other.P6p),
  P8p("P8p",this,other.P8p)
{

  useCTL4 = other.useCTL4;
  useCTL15 = other.useCTL15;

  verbose = other.verbose;

}



Double_t BoundDist::evaluate() const 
{

  double dist = 99.;
  double oldR = 0;
  double step = 0.02;
  double backFrac = 0.75;
  double precision = 0.001;

  double Radius = step;

  if ( eval4(0,0,0,0,0)>0 || eval15(0,0,0,0,0,0,0)>0 ) return 0;
  
  do {
    if (evalR(Radius)>0) {
      dist = Radius;
      Radius = Radius - backFrac*fabs(Radius-oldR);
      if (Radius<precision) Radius = precision;
      oldR = dist;
    } else {
      oldR = Radius;
      if (dist<99.)
	Radius = 0.67*Radius + 0.33*dist;
      else
	Radius = Radius + step;
    }
  } while (fabs(Radius-dist)>0.5*precision);

  return dist;

}

Double_t BoundDist::evalR(double Radius) const
{

  double xVal = 0;
  double rnd = 0;

  int nPoints = (int)(Radius*1e6);

  double delta[7];
  double lastParSq;

  bool nextRun;

  TRandom3 randGen(0);

  for (int iProbe=0; iProbe<nPoints; ++iProbe) {

    lastParSq = 1;
    nextRun = false;

    for (int iPar=0; iPar<6; ++iPar) {
      do {
	xVal = 2*randGen.Rndm()-1;
	rnd = randGen.Rndm();
      } while ( rnd > pow(1-xVal*xVal,2) );
      delta[iPar] = Radius * xVal;
      lastParSq -= xVal*xVal;
      if (lastParSq<0) {
	nextRun = true;
	break;
      }
    }

    if (nextRun) {
      --iProbe;
      continue;
    }

    delta[6] = Radius * sqrt(lastParSq);

    for (int iPar=0; iPar<7; ++iPar)
      if ( eval4(delta[iPar],delta[(iPar+1)%7],delta[(iPar+2)%7],delta[(iPar+3)%7],delta[(iPar+4)%7])>0 ) {
	if (verbose) std::cout<<"R "<<Radius<<" out of ctL4"<<std::endl;
	return 1;
      }
    for (int iPar=0; iPar<7; ++iPar)
      if ( eval15(delta[iPar],delta[(iPar+1)%7],delta[(iPar+2)%7],delta[(iPar+3)%7],delta[(iPar+4)%7],delta[(iPar+5)%7],delta[(iPar+6)%7])>0) {
	if (verbose) std::cout<<"R "<<Radius<<" out of ctL15"<<std::endl;
	return 1;
      }

  }

  if (verbose) std::cout<<"R "<<Radius<<" in"<<std::endl;

  return 0;

}


Double_t BoundDist::eval4(double dP2,
			  double dP4p,
			  double dP5p,
			  double dP6p,
			  double dP8p) const
{

  double ctL4phi1 = (P4p+dP4p)*(P4p+dP4p) + (P5p+dP5p)*(P5p+dP5p) + (P6p+dP6p)*(P6p+dP6p) + (P8p+dP8p)*(P8p+dP8p) - 2 + 2*fabs( 2*(P2+dP2) - (P4p+dP4p)*(P5p+dP5p) +(P6p+dP6p)*(P8p+dP8p) );

  if (ctL4phi1>0) return 1;
  
  return 0;

}


Double_t BoundDist::eval15(double dP1,
			   double dP2,
			   double dP3,
			   double dP4p,
			   double dP5p,
			   double dP6p,
			   double dP8p) const
{

  double a0 = 1 - (P1+dP1)*(P1+dP1) - (P6p+dP6p)*(P6p+dP6p)*(1+(P1+dP1)) - (P8p+dP8p)*(P8p+dP8p)*(1-(P1+dP1)) - 4*(P2+dP2)*(P2+dP2) - 4*(P2+dP2)*(P6p+dP6p)*(P8p+dP8p); 
  double a4 = 1 - (P1+dP1)*(P1+dP1) - (P4p+dP4p)*(P4p+dP4p)*(1+(P1+dP1)) - (P5p+dP5p)*(P5p+dP5p)*(1-(P1+dP1)) - 4*(P2+dP2)*(P2+dP2) + 4*(P2+dP2)*(P4p+dP4p)*(P5p+dP5p); 

  double a1 = 4*(P3+dP3)*(P8p+dP8p)*(P8p+dP8p) - 4*(P3+dP3)*(P6p+dP6p)*(P6p+dP6p) - 8*(P1+dP1)*(P3+dP3) + 2*(P5p+dP5p)*(P6p+dP6p)*(1+(P1+dP1)) - 2*(P4p+dP4p)*(P8p+dP8p)*(1-(P1+dP1)) - 4*(P2+dP2)*(P4p+dP4p)*(P6p+dP6p) + 4*(P2+dP2)*(P5p+dP5p)*(P8p+dP8p);
  double a3 = 4*(P3+dP3)*(P4p+dP4p)*(P4p+dP4p) - 4*(P3+dP3)*(P5p+dP5p)*(P5p+dP5p) + 8*(P1+dP1)*(P3+dP3) + 2*(P5p+dP5p)*(P6p+dP6p)*(1-(P1+dP1)) - 2*(P4p+dP4p)*(P8p+dP8p)*(1+(P1+dP1)) - 4*(P2+dP2)*(P4p+dP4p)*(P6p+dP6p) + 4*(P2+dP2)*(P5p+dP5p)*(P8p+dP8p);

  double a2 = 2 + 2*(P1+dP1)*(P1+dP1) - 8*(P2+dP2)*(P2+dP2) - 16*(P3+dP3)*(P3+dP3) - ((P4p+dP4p)*(P4p+dP4p)+(P6p+dP6p)*(P6p+dP6p))*(1-(P1+dP1)) - ((P5p+dP5p)*(P5p+dP5p)+(P8p+dP8p)*(P8p+dP8p))*(1+(P1+dP1)) + 4*(P2+dP2)*(P4p+dP4p)*(P5p+dP5p) - 4*(P2+dP2)*(P6p+dP6p)*(P8p+dP8p) + 8*(P3+dP3)*(P4p+dP4p)*(P8p+dP8p) + 8*(P3+dP3)*(P5p+dP5p)*(P6p+dP6p);

  double b0 = (P8p+dP8p)*(P8p+dP8p) - 1 - (P1+dP1) + 2*(P2+dP2) + (P6p+dP6p)*(P8p+dP8p); 
  double b2 = (P4p+dP4p)*(P4p+dP4p) - 1 + (P1+dP1) + 2*(P2+dP2) - (P4p+dP4p)*(P5p+dP5p); 
  double b1 = 2*(P4p+dP4p)*(P8p+dP8p) - 4*(P3+dP3) + (P4p+dP4p)*(P6p+dP6p) - (P5p+dP5p)*(P8p+dP8p);
  
  double c0 = (P8p+dP8p)*(P8p+dP8p) - 1 - (P1+dP1) - 2*(P2+dP2) - (P6p+dP6p)*(P8p+dP8p); 
  double c2 = (P4p+dP4p)*(P4p+dP4p) - 1 + (P1+dP1) - 2*(P2+dP2) + (P4p+dP4p)*(P5p+dP5p); 
  double c1 = 2*(P4p+dP4p)*(P8p+dP8p) - 4*(P3+dP3) - (P4p+dP4p)*(P6p+dP6p) + (P5p+dP5p)*(P8p+dP8p);
  
  int nSteps = 500;
  double phi, sin2, sincos, cos2;
  double ctL1, ctL5p, ctL5m;
  for (int step = 0; step<nSteps; ++step) {
    phi = 3.14159 * step / nSteps;
    if (useCTL15>0) phi=useCTL15;

    sin2 = sin(phi)*sin(phi);
    sincos = sin(phi)*cos(phi);
    cos2 = cos(phi)*cos(phi);

    ctL5p = b0*sin2 + b1*sincos + b2*cos2;
    if (ctL5p >= 0) continue;

    ctL5m = c0*sin2 + c1*sincos + c2*cos2;
    if (ctL5m >= 0) continue;

    ctL1 = a0*sin2*sin2 + a1*sin2*sincos + a2*sin2*cos2 + a3*sincos*cos2 + a4*cos2*cos2;
    if (ctL1 >= 0) continue;

    return 1;
    if (useCTL15>0) break;

  }
  
  return 0;

}
