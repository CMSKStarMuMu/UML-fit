/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "ParBound.h" 

ClassImp(ParBound) 

ParBound::ParBound(const char *name, const char *title, 
		   RooAbsReal& _P1,
		   RooAbsReal& _P2,
		   RooAbsReal& _P3,
		   RooAbsReal& _R45,
		   RooAbsReal& _R68,
		   RooAbsReal& _phi45,
		   RooAbsReal& _phi68,
		   Double_t _power,
		   Double_t _shift1,
		   Double_t _shift5,
		   Double_t _coeff,
		   Double_t _integral_value,
		   bool _verbose) :
  RooAbsPdf(name,title), 
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  R45("R45","R45",this,_R45),
  R68("R68","R68",this,_R68),
  phi45("phi45","phi45",this,_phi45),
  phi68("phi68","phi68",this,_phi68)
{

  verbose = _verbose;

  integral_value = _integral_value;

  shift1 = _shift1;
  shift5 = _shift5;
  coeff  = _coeff;
  power  = _power;

}


ParBound::ParBound(const char *name, const char *title, 
		   RooAbsReal& _P1,
		   RooAbsReal& _P2,
		   RooAbsReal& _P3,
		   RooAbsReal& _R45,
		   RooAbsReal& _R68,
		   RooAbsReal& _phi45,
		   RooAbsReal& _phi68,
		   Double_t _power,
		   Double_t _shift1,
		   Double_t _shift5,
		   Double_t _coeff) :
  RooAbsPdf(name,title), 
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  R45("R45","R45",this,_R45),
  R68("R68","R68",this,_R68),
  phi45("phi45","phi45",this,_phi45),
  phi68("phi68","phi68",this,_phi68)
{

  verbose = false;

  integral_value = 0.0;

  shift1 = _shift1;
  shift5 = _shift5;
  coeff  = _coeff;
  power = _power;

}


ParBound::ParBound(const ParBound& other, const char* name) :  
  RooAbsPdf(other,name), 
  P1("P1",this,other.P1),
  P2("P2",this,other.P2),
  P3("P3",this,other.P3),
  R45("R45",this,other.R45),
  R68("R68",this,other.R68),
  phi45("phi45",this,other.phi45),
  phi68("phi68",this,other.phi68)
{

  verbose = other.verbose;

  integral_value = other.integral_value;

  shift1 = other.shift1;
  shift5 = other.shift5;
  coeff  = other.coeff;
  power  = other.power;

}



Double_t ParBound::evaluate() const 
{

  double ret = 1.0;

  double P4p = R45*cos(phi45)*sqrt(0.5+P2)+R68*cos(phi68)*sqrt(0.5-P2);
  double P5p = R45*cos(phi45)*sqrt(0.5+P2)-R68*cos(phi68)*sqrt(0.5-P2);
  double P6p = R68*sin(phi68)*sqrt(0.5-P2)-R45*sin(phi45)*sqrt(0.5+P2);
  double P8p = R68*sin(phi68)*sqrt(0.5-P2)+R45*sin(phi45)*sqrt(0.5+P2);

  double a0 = 1 - P1*P1 - P6p*P6p*(1+P1) - P8p*P8p*(1-P1) - 4*P2*P2 - 4*P2*P6p*P8p; 
  double a4 = 1 - P1*P1 - P4p*P4p*(1+P1) - P5p*P5p*(1-P1) - 4*P2*P2 + 4*P2*P4p*P5p; 

  double a1 = 4*P3*P8p*P8p - 4*P3*P6p*P6p - 8*P1*P3 + 2*P5p*P6p*(1+P1) - 2*P4p*P8p*(1-P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
  double a3 = 4*P3*P4p*P4p - 4*P3*P5p*P5p + 8*P1*P3 + 2*P5p*P6p*(1-P1) - 2*P4p*P8p*(1+P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;

  double a2 = 2 + 2*P1*P1 - 8*P2*P2 - 16*P3*P3 - (P4p*P4p+P6p*P6p)*(1-P1) - (P5p*P5p+P8p*P8p)*(1+P1) + 4*P2*P4p*P5p - 4*P2*P6p*P8p + 8*P3*P4p*P8p + 8*P3*P5p*P6p;

  double b0 = P8p*P8p - 1 - P1 + 2*P2 + P6p*P8p; 
  double b2 = P4p*P4p - 1 + P1 + 2*P2 - P4p*P5p; 
  double b1 = P4p*P8p - 2*P3 + 0.5 * ( P4p*P6p - P5p*P8p );
  
  double c0 = P8p*P8p - 1 - P1 - 2*P2 - P6p*P8p; 
  double c2 = P4p*P4p - 1 + P1 - 2*P2 + P4p*P5p; 
  double c1 = P4p*P8p - 2*P3 - 0.5 * ( P4p*P6p - P5p*P8p );
  
  int nSteps = 100;
  double phi, sin2, sincos, cos2;
  double ctL1, ctL5p, ctL5m;
  double base1, base5, exponent, local_ret;
  for (int step = 0; step<nSteps; ++step) {
    phi = 3.14159 * step / nSteps;
    sin2 = sin(phi)*sin(phi);
    sincos = sin(phi)*cos(phi);
    cos2 = cos(phi)*cos(phi);

    ctL5p = b0*sin2 + b1*sincos + b2*cos2;
    ctL5m = c0*sin2 + c1*sincos + c2*cos2;

    ctL1 = a0*sin2*sin2 + a1*sin2*sincos + a2*sin2*cos2 + a3*sincos*cos2 + a4*cos2*cos2;

    base1 = 1 - ctL1 * 0.1*shift1;
    base5 = 1 - TMath::Max(ctL5m,ctL5p) * 0.1*shift5;

    if ( base1 <=0 || base5 <=0 ) continue;

    exponent = -0.0001*coeff * pow(base1,power) * pow(base5,power);
    local_ret = exp(exponent);

    if (verbose) {
      if (ctL5m<0 && ctL5p<0 && ctL1<0) std::cout<<"[OUT] 1 "<<ctL1<<" 5p "<<ctL5p<<" 5m "<<ctL5m<<" phi "<<phi<<" base1 "<<base1<<" base5 "<<base5<<" -> exp("<<exponent<<")"<<std::endl;
      // else std::cout<<"[IN]  1 "<<ctL1<<" 5p "<<ctL5p<<" 5m "<<ctL5m<<" phi "<<phi<<" base1 "<<base1<<" base5 "<<base5<<" -> exp("<<exponent<<")"<<std::endl;
    }
    if (local_ret<1e-300) return 1e-300;

    if ( ret > local_ret ) ret = local_ret;
  }
  
  return ret;

}

namespace {
  Bool_t fullRangeP1(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for P1
    return (range == 0 || strlen(range) == 0)
      ? (std::fabs(x.min() + 1.) < 1.e-5 && std::fabs(x.max() - 1.) < 1.e-5)
      : (std::fabs(x.min(range) + 1.) < 1.e-5 && std::fabs(x.max(range) - 1.) < 1.e-5);
  }
  Bool_t fullRangeP2(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for P2 and P3
    return (range == 0 || strlen(range) == 0)
      ? (std::fabs(x.min() + 0.5) < 1.e-5 && std::fabs(x.max() - 0.5) < 1.e-5)
      : (std::fabs(x.min(range) + 0.5) < 1.e-5 && std::fabs(x.max(range) - 0.5) < 1.e-5);
  }
  Bool_t fullRangeR(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for R parameters
    return (range == 0 || strlen(range) == 0)
      ? (std::fabs(x.min()) < 1.e-5 && std::fabs(x.max() - 1.0) < 1.e-5)
      : (std::fabs(x.min(range)) < 1.e-5 && std::fabs(x.max(range) - 1.0) < 1.e-5);
  }
  Bool_t fullRangePhi(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for phi parameters
    return (range == 0 || strlen(range) == 0)
      ? (std::fabs(x.min() + 0.5*TMath::Pi()) < 1.e-5 && std::fabs(x.max() - 1.5*TMath::Pi()) < 1.e-5)
      : (std::fabs(x.min(range) + 0.5*TMath::Pi()) < 1.e-5 && std::fabs(x.max(range) - 1.5*TMath::Pi()) < 1.e-5);
  }
}

Int_t ParBound::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{

  if (integral_value<=0) return 0;

  if ( matchArgs(allVars,analVars,P1,P2,P3) && matchArgs(allVars,analVars,R45,R68,phi45,phi68) )
    if ( fullRangeP1 (P1,rangeName) &&
	 fullRangeP2 (P2,rangeName) &&
	 fullRangeP2 (P3,rangeName) &&
	 fullRangeR  (R45,rangeName) &&
	 fullRangeR  (R68,rangeName) &&
	 fullRangePhi(phi45,rangeName) &&
	 fullRangePhi(phi68,rangeName) )
      return 1 ;

  return 0 ;

}

Double_t ParBound::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code>0 && code<2) ;

  return integral_value;

}
