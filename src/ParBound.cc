/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "ParBound.h" 

ClassImp(ParBound) 

ParBound::ParBound(const char *name, const char *title, 
		   RooAbsReal& _P1,
		   RooAbsReal& _P2,
		   RooAbsReal& _P3,
		   RooAbsReal& _P4p,
		   RooAbsReal& _P5p,
		   RooAbsReal& _P6p,
		   RooAbsReal& _P8p) :
  RooAbsPdf(name,title), 
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  P4p("P4p","P4p",this,_P4p),
  P5p("P5p","P5p",this,_P5p),
  P6p("P6p","P6p",this,_P6p),
  P8p("P8p","P8p",this,_P8p)
{
}


ParBound::ParBound(const ParBound& other, const char* name) :  
  RooAbsPdf(other,name), 
  P1("P1",this,other.P1),
  P2("P2",this,other.P2),
  P3("P3",this,other.P3),
  P4p("P4p",this,other.P4p),
  P5p("P5p",this,other.P5p),
  P6p("P6p",this,other.P6p),
  P8p("P8p",this,other.P8p)
{
}



Double_t ParBound::evaluate() const 
{

  // Physical Region: should be < 0
  double ctL4phi1 = P4p*P4p + P5p*P5p + P6p*P6p + P8p*P8p - 2 + 2*fabs( 2*P2 - P4p*P5p +P6p*P8p );
  // Physical Region: should be < 0
  double ctK2 = P1*P1 + 4*P2*P2 + 4*P3*P3 -1;
  // Physical Region: should be < 0
  double ctL2phi1 = P5p*P5p*(1-P1) + P6p*P6p*(1+P1) - 4*P3*P5p*P6p - 1 + P1*P1 + 4*P3*P3;
  // Physical Region: should be < 0
  double ctL2phi2 = P6p*P6p - 1 + P1;
  // Physical Region: should be < 0
  double ctL2phi3 = P5p*P5p - 1 - P1;

  double x = TMath::Max(ctL4phi1, ctK2);
  x = TMath::Max(x, ctL2phi1);
  x = TMath::Max(x, ctL2phi2);
  x = TMath::Max(x, ctL2phi3);
  double penalty1 = 1.;
  penalty1 = x > 0 ? exp(-1000*x*x*x*x) : 1.;
  if (penalty1 < 1.E-8)  penalty1 = 1.E-8;
//   double penalty1 = exp(-400*x*x*x*x);

  // at least one of the three should be > 0
  double a0 = 1 - P1*P1 - P6p*P6p*(1+P1) - P8p*P8p*(1-P1) - 4*P2*P2 - 4*P2*P6p*P8p; 
  double a4 = 1 - P1*P1 - P4p*P4p*(1+P1) - P5p*P5p*(1-P1) - 4*P2*P2 + 4*P2*P4p*P5p; 
  double a1 = 4*P3*P8p*P8p - 4*P3*P6p*P6p - 8*P1*P3 + 2*P5p*P6p*(1+P1) - 2*P4p*P8p*(1-P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
  double a3 = 4*P3*P4p*P4p - 4*P3*P5p*P5p + 8*P1*P3 + 2*P5p*P6p*(1-P1) - 2*P4p*P8p*(1+P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
  double a2 = 2 + 2*P1*P1 - 8*P2*P2 - 16*P3*P3 - (P4p*P4p+P6p*P6p)*(1-P1) - (P5p*P5p+P8p*P8p)*(1+P1) + 4*P2*P4p*P5p - 4*P2*P6p*P8p + 8*P3*P4p*P8p + 8*P3*P5p*P6p;
  double b0 = P8p*P8p - 1 - P1 + 2*P2 + P6p*P8p; 
  double b2 = P4p*P4p - 1 + P1 + 2*P2 - P4p*P5p; 
  double b1 = P4p*P8p - 2*P3 + 0.5 * ( P4p*P6p - P5p*P8p );
  double c0 = P8p*P8p - 1 - P1 - 2*P2 - P6p*P8p; 
  double c2 = P4p*P4p - 1 + P1 - 2*P2 + P4p*P5p; 
  double c1 = P4p*P8p - 2*P3 - 0.5 * ( P4p*P6p - P5p*P8p );
  
  int nSteps = 100;
  int halfSteps = nSteps/2;
  double phi, sin2, sincos, cos2;
  double ctL1, ctL5p, ctL5m;
  double tmp_y = 0;
  double y = 0;
  for (int step = 0; step < nSteps+1; ++step) {
    phi = 3.14159 * step / nSteps;
    sin2 = sin(phi)*sin(phi);
    sincos = sin(phi)*cos(phi);
    cos2 = cos(phi)*cos(phi);

    ctL5p = b0*sin2 + b1*sincos + b2*cos2;
    if ( ctL5p >= 0 ) continue;
    ctL5m = c0*sin2 + c1*sincos + c2*cos2;
    if ( ctL5m >= 0 ) continue;
    ctL1 = a0*sin2*sin2 + a1*sin2*sincos + a2*sin2*cos2 + a3*sincos*cos2 + a4*cos2*cos2;
    if ( ctL1 >= 0 ) continue;

    tmp_y = TMath::Min(ctL5p, TMath::Min( ctL5m, ctL1));
    if (tmp_y < y) y = tmp_y; 
  }  

  double penalty2 = 1;
  penalty2 = y < 0 ? exp(-1000*y*y*y*y) : 1.;
  if (penalty2 < 1.E-8)  penalty2 = 1.E-8;

  if(verbose){
    std::cout<<Form("Q2Bin=%d \
       cond 0=%d (%f)\
       1=%d \
       2=%d \
       3=%d \
       4=%d \
       5=%d (%f) \n",
       Q2Bin,
       ctL4phi1<=0, ctL4phi1,
       ctK2<=0,
       ctL2phi1<=0,
       ctL2phi2<=0,
       ctL2phi1<=0,
       y>=0, y)
       <<std::endl;
  } 
  return TMath::Min(penalty1, penalty2);

}
