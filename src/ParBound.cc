/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "ParBound.h" 

ClassImp(ParBound) 

ParBound::ParBound(const char *name, const char *title, 
		   RooAbsReal& _P1,
		   RooAbsReal& _P2,
		   RooAbsReal& _P3,
		   RooAbsReal& _P4p,
		   RooAbsReal& _P5p,
		   RooAbsReal& _P6p,
		   RooAbsReal& _P8p) :
  RooAbsPdf(name,title), 
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  P4p("P4p","P4p",this,_P4p),
  P5p("P5p","P5p",this,_P5p),
  P6p("P6p","P6p",this,_P6p),
  P8p("P8p","P8p",this,_P8p)
{
}


ParBound::ParBound(const ParBound& other, const char* name) :  
  RooAbsPdf(other,name), 
  P1("P1",this,other.P1),
  P2("P2",this,other.P2),
  P3("P3",this,other.P3),
  P4p("P4p",this,other.P4p),
  P5p("P5p",this,other.P5p),
  P6p("P6p",this,other.P6p),
  P8p("P8p",this,other.P8p)
{
}



Double_t ParBound::evaluate() const 
{

  double power = 6.0;
  double ret = 1.0;

  double ctL4phi1 = P4p*P4p + P5p*P5p + P6p*P6p + P8p*P8p - 2 + 2*fabs( 2*P2 - P4p*P5p +P6p*P8p );
  // std::cout<<" ctL4phi1="<<ctL4phi1<<std::endl;
  
  if ( ctL4phi1>0 ) {
    // std::cout<<"ctL4phi1="<<ctL4phi1<<std::endl;
    ret = exp(-690*pow(ctL4phi1/16.0,power/2));
    if (ret==0) {
      std::cout<<"ERROR! Precision not sufficient for ctL4phi1="<<ctL4phi1
	       <<" ret=exp("<<-690*pow(ctL4phi1/16.0,power/2)<<")"<<std::endl;
      return 1e-300;
    }
  }

  double ctK2 = P1*P1 + 4*P2*P2 + 4*P3*P3 -1;

  if ( ctK2>0 ) {
    double local_ret = exp(-690*pow(ctK2/2.0,power/2));
    if (local_ret==0) {
      std::cout<<"ERROR! Precision not sufficient for ctK2="<<ctK2
	       <<" ret=exp("<<-690*pow(ctK2/2.0,power/2)<<")"<<std::endl;
      return 1e-300;
    }
    if ( ret > local_ret ) ret = local_ret;
  }

  double ctL2phi1 = P5p*P5p*(1-P1) + P6p*P6p*(1+P1) - 4*P3*P5p*P6p - 1 + P1*P1 + 4*P3*P3;
  double ctL2phi2 = P6p*P6p - 1 + P1;
  double ctL2phi3 = P5p*P5p - 1 - P1;
  // std::cout<<" ctL2phi1="<<ctL2phi1<<" ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3<<std::endl;

  if ( ctL2phi1>0 ) {
    // std::cout<<"ctL2phi1="<<ctL2phi1<<" ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3<<std::endl;
    double local_ret = exp(-690*pow(ctL2phi1/9.0,power/3));
    if (local_ret==0) {
      std::cout<<"ERROR! Precision not sufficient for ctL2phi1="<<ctL2phi1
	       <<" ret=exp("<<-690*pow(ctL2phi1/9.0,power/3)<<")"<<std::endl;
      return 1e-300;
    }
    if ( ret > local_ret ) ret = local_ret;
  }
  if ( ctL2phi2>0 || ctL2phi3>0 ) {
    double local_ret = exp(-690*pow(TMath::Max(ctL2phi2,ctL2phi3)/2.0,power/2));
    if (local_ret==0) {
      std::cout<<"ERROR! Precision not sufficient for ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3
	       <<" ret=exp("<<-690*pow(TMath::Max(ctL2phi2,ctL2phi3)/2.0,power/2)<<")"<<std::endl;
      return 1e-300;
    }
    if ( ret > local_ret ) ret = local_ret;
  }
  if ( ctL2phi1<0 && ctL2phi2*ctL2phi3<0 ) std::cout<<"ERROR! ctL2phi2 and ctL2phi3 have different sign! ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3<<std::endl;

  // Avoid numerical computation when the boundary is already exceeded
  // except when the constraint is very weak (0.01<ret<1), and a stronger one can be obtained with the following checks
  if ( ret < 0.01 ) return ret;

  double a0 = 1 - P1*P1 - P6p*P6p*(1+P1) - P8p*P8p*(1-P1) - 4*P2*P2 - 4*P2*P6p*P8p; 
  double a4 = 1 - P1*P1 - P4p*P4p*(1+P1) - P5p*P5p*(1-P1) - 4*P2*P2 + 4*P2*P4p*P5p; 

  double a1 = 4*P3*P8p*P8p - 4*P3*P6p*P6p - 8*P1*P3 + 2*P5p*P6p*(1+P1) - 2*P4p*P8p*(1-P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
  double a3 = 4*P3*P4p*P4p - 4*P3*P5p*P5p + 8*P1*P3 + 2*P5p*P6p*(1-P1) - 2*P4p*P8p*(1+P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;

  double a2 = 2 + 2*P1*P1 - 8*P2*P2 - 16*P3*P3 - (P4p*P4p+P6p*P6p)*(1-P1) - (P5p*P5p+P8p*P8p)*(1+P1) + 4*P2*P4p*P5p - 4*P2*P6p*P8p + 8*P3*P4p*P8p + 8*P3*P5p*P6p;

  double b0 = P8p*P8p - 1 - P1 + 2*P2 + P6p*P8p; 
  double b2 = P4p*P4p - 1 + P1 + 2*P2 - P4p*P5p; 
  double b1 = P4p*P8p - 2*P3 + 0.5 * ( P4p*P6p - P5p*P8p );
  
  double c0 = P8p*P8p - 1 - P1 - 2*P2 - P6p*P8p; 
  double c2 = P4p*P4p - 1 + P1 - 2*P2 + P4p*P5p; 
  double c1 = P4p*P8p - 2*P3 - 0.5 * ( P4p*P6p - P5p*P8p );
  
  int nSteps = 100;
  int halfSteps = nSteps/2;
  double phi, sin2, sincos, cos2;
  double ctL1, ctL5p, ctL5m;
  for (int step = -1*halfSteps; step<halfSteps; ++step) {
    phi = 3.14159 * step / halfSteps;
    sin2 = sin(phi)*sin(phi);
    sincos = sin(phi)*cos(phi);
    cos2 = cos(phi)*cos(phi);

    ctL5p = b0*sin2 + b1*sincos + b2*cos2;
    if ( ctL5p >= 0 ) continue;
    ctL5m = c0*sin2 + c1*sincos + c2*cos2;
    if ( ctL5m >= 0 ) continue;

    ctL1 = a0*sin2*sin2 + a1*sin2*sincos + a2*sin2*cos2 + a3*sincos*cos2 + a4*cos2*cos2;
    if ( ctL1 >= 0 ) continue;

    double local_ret = exp(690*TMath::Max(-1*pow(-1*ctL1/1.1,power/3),-1*pow(-1*TMath::Max(ctL5m,ctL5p)/3.0,power/2)));
    if (local_ret==0) {
      std::cout<<"ERROR! Precision not sufficient for ctL5p="<<ctL5p<<" ctL5m="<<ctL5m<<" ctL1="<<ctL1
	       <<" ret=exp("<<690*TMath::Max(-1*pow(-1*ctL1/1.1,power/3),-1*pow(-1*TMath::Max(ctL5m,ctL5p)/3.0,power/2))<<")"<<std::endl;
      return 1e-300;
    }
    if ( ret > local_ret ) ret = local_ret;
  }
  
  return ret;

}
