/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "PdfSigAng.h" 

ClassImp(PdfSigAng) 

PdfSigAng::PdfSigAng(const char *name, const char *title, 
		     RooAbsReal& _ctK,
		     RooAbsReal& _ctL,
		     RooAbsReal& _phi,
		     RooAbsReal& _Fl,
		     RooAbsReal& _P1,
		     RooAbsReal& _P2,
		     RooAbsReal& _P3,
		     RooAbsReal& _P4p,
		     RooAbsReal& _P5p,
		     RooAbsReal& _P6p,
		     RooAbsReal& _P8p,
		     RooAbsReal& _mFrac,
		     RooAbsReal& _EffC,
		     RooAbsReal& _EffW,
		     std::vector<double> _intCPart,
		     std::vector<double> _intWPart) :
  RooAbsPdf(name,title), 
  ctK("ctK","ctK",this,_ctK),
  ctL("ctL","ctL",this,_ctL),
  phi("phi","phi",this,_phi),
  Fl("Fl","Fl",this,_Fl),
  P1("P1","P1",this,_P1),
  P2("P2","P2",this,_P2),
  P3("P3","P3",this,_P3),
  P4p("P4p","P4p",this,_P4p),
  P5p("P5p","P5p",this,_P5p),
  P6p("P6p","P6p",this,_P6p),
  P8p("P8p","P8p",this,_P8p),
  mFrac("mFrac","mFrac",this,_mFrac),
  EffC("EffC","corr-tag efficiency",this,_EffC),
  EffW("EffW","wrong-tag efficiency",this,_EffW),
  intCPart(_intCPart),
  intWPart(_intWPart)
{
}


PdfSigAng::PdfSigAng(const PdfSigAng& other, const char* name) :  
  RooAbsPdf(other,name), 
  ctK("ctK",this,other.ctK),
  ctL("ctL",this,other.ctL),
  phi("phi",this,other.phi),
  Fl("Fl",this,other.Fl),
  P1("P1",this,other.P1),
  P2("P2",this,other.P2),
  P3("P3",this,other.P3),
  P4p("P4p",this,other.P4p),
  P5p("P5p",this,other.P5p),
  P6p("P6p",this,other.P6p),
  P8p("P8p",this,other.P8p),
  mFrac("mFrac",this,other.mFrac),
  EffC("EffC",this,other.EffC),
  EffW("EffW",this,other.EffW),
  intCPart(other.intCPart),
  intWPart(other.intWPart)
{
}



Double_t PdfSigAng::evaluate() const 
{
  double sqrtFL = sqrt(Fl*(1.-Fl));
//  double sqrtFL = sqrt(Fl)*sqrt(1.-Fl);
  if (TMath::IsNaN(sqrtFL)) sqrtFL=1e-32;
  
  Double_t retCT =   (
//  Double_t retCT =  9./(32*3.14159265) * (
					  0.75*(1-Fl)              * intCPart[0]
					  + Fl                     * intCPart[1]
					  + 0.25*(1-Fl)            * intCPart[2]
					  - Fl                     * intCPart[3]
					  + 0.5*P1*(1-Fl)          * intCPart[4]
					  + 0.5*sqrtFL        *P4p * intCPart[5]
					  + sqrtFL        *P5p     * intCPart[6]
					  - sqrtFL        *P6p     * intCPart[7]
					  + 0.5*sqrtFL        *P8p * intCPart[8]
					  + 2*(1-Fl)*P2            * intCPart[9]
					  - P3*(1-Fl)              * intCPart[10]
					  );
  
  Double_t retWT =   (
//  Double_t retWT =  9./(32*3.14159265) * (
					  0.75*(1-Fl)              * intWPart[0]
					  + Fl                     * intWPart[1]
					  + 0.25*(1-Fl)            * intWPart[2]
					  - Fl                     * intWPart[3]
					  + 0.5*P1*(1-Fl)          * intWPart[4]
					  + 0.5*sqrtFL        *P4p * intWPart[5]
					  - sqrtFL        *P5p     * intWPart[6]
					  - sqrtFL        *P6p     * intWPart[7]
					  - 0.5*sqrtFL        *P8p * intWPart[8]
					  - 2*(1-Fl)*P2            * intWPart[9]
					  + P3*(1-Fl)              * intWPart[10]
					  );

// double power = 2.0;
//   double RET= 1.0;
// 
//   double ctL4phi1 = P4p*P4p + P5p*P5p + P6p*P6p + P8p*P8p - 2 + 2*fabs( 2*P2 - P4p*P5p +P6p*P8p );
//   // std::cout<<" ctL4phi1="<<ctL4phi1<<std::endl;
//   
//   if ( ctL4phi1>0 ) {
//     // std::cout<<"ctL4phi1="<<ctL4phi1<<std::endl;
//     RET= exp(-pow(ctL4phi1/16.0,power/2));
// //    RET= exp(-690*pow(ctL4phi1/16.0,power/2));
//     if (RET==0) {
//       std::cout<<"ERROR! Precision not sufficient for ctL4phi1="<<ctL4phi1
// 	       <<" ret=exp("<<-pow(ctL4phi1/16.0,power/2)<<")"<<std::endl;
//       return 1e-300;
//     }
//   }
// 
//   double ctK2 = P1*P1 + 4*P2*P2 + 4*P3*P3 -1;
// 
//   if ( ctK2>0 ) {
//     double local_RET= exp(-pow(ctK2/2.0,power/2));
//     if (local_RET==0) {
//       std::cout<<"ERROR! Precision not sufficient for ctK2="<<ctK2
// 	       <<" ret=exp("<<-pow(ctK2/2.0,power/2)<<")"<<std::endl;
//       return 1e-300;
//     }
//     if ( RET> local_RET) RET= local_RET;
//   }
// 
//   double ctL2phi1 = P5p*P5p*(1-P1) + P6p*P6p*(1+P1) - 4*P3*P5p*P6p - 1 + P1*P1 + 4*P3*P3;
//   double ctL2phi2 = P6p*P6p - 1 + P1;
//   double ctL2phi3 = P5p*P5p - 1 - P1;
//   // std::cout<<" ctL2phi1="<<ctL2phi1<<" ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3<<std::endl;
// 
//   if ( ctL2phi1>0 ) {
//     // std::cout<<"ctL2phi1="<<ctL2phi1<<" ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3<<std::endl;
//     double local_RET= exp(-pow(ctL2phi1/9.0,power/3));
//     if (local_RET==0) {
//       std::cout<<"ERROR! Precision not sufficient for ctL2phi1="<<ctL2phi1
// 	       <<" ret=exp("<<-pow(ctL2phi1/9.0,power/3)<<")"<<std::endl;
//       return 1e-300;
//     }
//     if ( RET> local_RET) RET= local_RET;
//   }
//   
//   if (RET!=1.0) return RET;
//   if ( ctL2phi2>0 || ctL2phi3>0 ) {
//     double local_RET= exp(-pow(TMath::Max(ctL2phi2,ctL2phi3)/2.0,power/2));
//     if (local_RET==0) {
//       std::cout<<"ERROR! Precision not sufficient for ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3
// 	       <<" ret=exp("<<-pow(TMath::Max(ctL2phi2,ctL2phi3)/2.0,power/2)<<")"<<std::endl;
//       return 1e-300;
//     }
//     if ( RET> local_RET) RET= local_RET;
//   }
//   if ( ctL2phi1<0 && ctL2phi2*ctL2phi3<0 ) std::cout<<"ERROR! ctL2phi2 and ctL2phi3 have different sign! ctL2phi2="<<ctL2phi2<<" ctL2phi3="<<ctL2phi3<<std::endl;
// 
//   // Avoid numerical computation when the boundary is already exceeded
//   // except when the constraint is very weak (0.01<ret<1), and a stronger one can be obtained with the following checks
//   if ( RET< 0.01 ) return RET;
// 
//   double a0 = 1 - P1*P1 - P6p*P6p*(1+P1) - P8p*P8p*(1-P1) - 4*P2*P2 - 4*P2*P6p*P8p; 
//   double a4 = 1 - P1*P1 - P4p*P4p*(1+P1) - P5p*P5p*(1-P1) - 4*P2*P2 + 4*P2*P4p*P5p; 
// 
//   double a1 = 4*P3*P8p*P8p - 4*P3*P6p*P6p - 8*P1*P3 + 2*P5p*P6p*(1+P1) - 2*P4p*P8p*(1-P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
//   double a3 = 4*P3*P4p*P4p - 4*P3*P5p*P5p + 8*P1*P3 + 2*P5p*P6p*(1-P1) - 2*P4p*P8p*(1+P1) - 4*P2*P4p*P6p + 4*P2*P5p*P8p;
// 
//   double a2 = 2 + 2*P1*P1 - 8*P2*P2 - 16*P3*P3 - (P4p*P4p+P6p*P6p)*(1-P1) - (P5p*P5p+P8p*P8p)*(1+P1) + 4*P2*P4p*P5p - 4*P2*P6p*P8p + 8*P3*P4p*P8p + 8*P3*P5p*P6p;
// 
//   double b0 = P8p*P8p - 1 - P1 + 2*P2 + P6p*P8p; 
//   double b2 = P4p*P4p - 1 + P1 + 2*P2 - P4p*P5p; 
//   double b1 = P4p*P8p - 2*P3 + 0.5 * ( P4p*P6p - P5p*P8p );
//   
//   double c0 = P8p*P8p - 1 - P1 - 2*P2 - P6p*P8p; 
//   double c2 = P4p*P4p - 1 + P1 - 2*P2 + P4p*P5p; 
//   double c1 = P4p*P8p - 2*P3 - 0.5 * ( P4p*P6p - P5p*P8p );
//   
//   int nSteps = 100;
//   int halfSteps = nSteps/2;
//   double phi, sin2, sincos, cos2;
//   double ctL1, ctL5p, ctL5m;
//   for (int step = -1*halfSteps; step<halfSteps; ++step) {
//     phi = 3.14159 * step / halfSteps;
//     sin2 = sin(phi)*sin(phi);
//     sincos = sin(phi)*cos(phi);
//     cos2 = cos(phi)*cos(phi);
// 
//     ctL5p = b0*sin2 + b1*sincos + b2*cos2;
//     if ( ctL5p >= 0 ) continue;
//     ctL5m = c0*sin2 + c1*sincos + c2*cos2;
//     if ( ctL5m >= 0 ) continue;
// 
//     ctL1 = a0*sin2*sin2 + a1*sin2*sincos + a2*sin2*cos2 + a3*sincos*cos2 + a4*cos2*cos2;
//     if ( ctL1 >= 0 ) continue;
// 
//     double local_RET= exp(690*TMath::Max(-1*pow(-1*ctL1/1.1,power/3),-1*pow(-1*TMath::Max(ctL5m,ctL5p)/3.0,power/2)));
//     if (local_RET==0) {
//       std::cout<<"ERROR! Precision not sufficient for ctL5p="<<ctL5p<<" ctL5m="<<ctL5m<<" ctL1="<<ctL1
// 	       <<" ret=exp("<<690*TMath::Max(-1*pow(-1*ctL1/1.1,power/3),-1*pow(-1*TMath::Max(ctL5m,ctL5p)/3.0,power/2))<<")"<<std::endl;
//       return 1e-300;
//     }
//     if ( RET> local_RET) RET= local_RET;
//   }
// 
//   if(RET!=1.0 )return RET;
  
     double unoCTK = (1-ctK)*(1+ctK);
     double unoCTL = (1-ctL)*(1+ctL);
//double unoCTK = (1-ctK*ctK);
//double unoCTL = (1-ctL*ctL);
  double sqrtCTL = sqrt(unoCTL);
//   if ( sqrtCL<1e-32 ) sqrtCL=1e-32;

  double decCC =   0.75 * (1-Fl) * unoCTK +
		   Fl * ctK*ctK +
		   ( 0.25 * (1-Fl) * unoCTK - Fl * ctK*ctK ) * ( 2 * ctL*ctL -1 ) +
		   0.5 * P1 * (1-Fl) * unoCTK * unoCTL * cos(2*phi);

 //  double decCT = ( 0.75 * (1-Fl) * unoCTK +
// 		   Fl * ctK*ctK +
// 		   ( 0.25 * (1-Fl) * unoCTK - Fl * ctK*ctK ) * ( 2 * ctL*ctL -1 ) +
// 		   0.5 * P1 * (1-Fl) * unoCTK * unoCTL * cos(2*phi) +
  double decCT1 =    2 * cos(phi) * ctK * sqrt(Fl * (1-Fl) * unoCTK) * ( P4p * ctL * sqrtCTL + P5p * sqrtCTL ) +
		     2 * sin(phi) * ctK * sqrt(Fl * (1-Fl) * unoCTK) * ( P8p * ctL * sqrtCTL - P6p * sqrtCTL ) +
		     2 * P2 * (1-Fl) * unoCTK * ctL -
		     P3 * (1-Fl) * unoCTK * unoCTL * sin(2*phi) ;
	
   
//   if ( decCT<1e-31 || TMath::IsNaN(decCT) ) decCT = 1e-31;

//   double decWT = ( 0.75 * (1-Fl) * unoCTK +
// 		   Fl * ctK*ctK +
// 		   ( 0.25 * (1-Fl) * unoCTK - Fl * ctK*ctK ) * ( 2 * ctL*ctL -1 ) +
// 		   0.5 * P1 * (1-Fl) * unoCTK * unoCTL * cos(2*phi) -
  double decWT1 =  - 2 * cos(phi) * ctK * sqrt(Fl * (1-Fl) * unoCTK) * ( -1. * P4p * ctL * sqrtCTL + P5p * sqrtCTL ) +
		     2 * sin(phi) * ctK * sqrt(Fl * (1-Fl) * unoCTK) * ( -1. * P8p * ctL * sqrtCTL - P6p * sqrtCTL ) -
		     2 * P2 * (1-Fl) * unoCTK * ctL +
		     P3 * (1-Fl) * unoCTK * unoCTL * sin(2*phi) ;
		     
//		     2 * cos(phi) * ctK * sqrt(Fl * (1-Fl) * unoCTK) * ( P4p * ctL)-
//		     2 * sin(phi) * ctK * sqrt(Fl * (1-Fl) * unoCTK) * ( P6p * sqrtCTL )
  		     
//		     2 * ctK * sqrt(Fl * (1-Fl) * unoCTK) * (cos(phi)* P4p * ctL - sin(phi) * P6p * sqrtCTL )
		     
		     
  double decCT = decCC+decCT1;
  double decWT = decCC+decWT1;
  
  
//   if(!(decCT>=0)){
// //     std::cout<<"ERR deltaT  = "<<decCT1-decWT1<<std::endl;
//    return 1e-32;
//   } 
  
//   if(decCT>=0 && decWT>=0) {
// //  if((decCC-TMath::Max(-decCT1,-decWT1))>0) {
// //  if((decCC-TMath::Max(-decCT1,-decWT1))>0) {
//     std::cout<<"deltaT  = "<<decCT1-decWT1<<std::endl;
//   }else{  
//     std::cout<<"ERR deltaT  = "<<decCT1-decWT1<<std::endl;
//     return 1e-32;
//   } 
//
// //===============================================================================================================================  
//   
//   double phiTMP=0;
//   double decCC2=0;
//   double decCT2=0;
//   double decWT2=0;
//   double CTKTMP=0;
//   double CTLTMP=0;
//   double unoCTKTMP = 0;
//   double unoCTLTMP = 0;
//   double sqrtCTLTMP= 0;
//   
//   for (int i=-2;i<=2;i++){ 
//    for (int j=-2;j<=2;j++){ 
//     for (int k=-2;k<=2;k++){ 
// 
//  	 phiTMP=TMath::Pi()/2.*i;
//  	 CTKTMP=j/2.;
//  	 CTLTMP=k/2.;
//  	 unoCTKTMP = (1-CTKTMP)*(1+CTKTMP);
//  	 unoCTLTMP = (1-CTLTMP)*(1+CTLTMP);
//  	 sqrtCTLTMP = sqrt(unoCTLTMP);
//  
//  	 decCC2 =   0.75 * (1-Fl) * unoCTKTMP +
// 			  Fl * CTKTMP*CTKTMP +
// 			  ( 0.25 * (1-Fl) * unoCTKTMP - Fl * CTKTMP*CTKTMP ) * ( 2 * CTLTMP*CTLTMP -1 ) +
// 			  0.5 * P1 * (1-Fl) * unoCTKTMP * unoCTLTMP * cos(2*phiTMP);
// 
//  	 decCT2 =    2 * cos(phiTMP) * CTKTMP * sqrt(Fl * (1-Fl) * unoCTKTMP) * ( P4p * CTLTMP * sqrtCTLTMP + P5p * sqrtCTLTMP ) +
// 			    2 * sin(phiTMP) * CTKTMP * sqrt(Fl * (1-Fl) * unoCTKTMP) * ( P8p * CTLTMP * sqrtCTLTMP - P6p * sqrtCTLTMP ) +
// 			    2 * P2 * (1-Fl) * unoCTKTMP * CTLTMP -
// 			    P3 * (1-Fl) * unoCTKTMP * unoCTLTMP * sin(2*phiTMP) ;
// 	
//  
//  	 decWT2 =  - 2 * cos(phiTMP) * CTKTMP * sqrt(Fl * (1-Fl) * unoCTKTMP) * ( -1. * P4p * CTLTMP * sqrtCTLTMP + P5p * sqrtCTLTMP ) +
// 			    2 * sin(phiTMP) * CTKTMP * sqrt(Fl * (1-Fl) * unoCTKTMP) * ( -1. * P8p * CTLTMP * sqrtCTLTMP - P6p * sqrtCTLTMP ) -
// 			    2 * P2 * (1-Fl) * unoCTKTMP * CTLTMP +
// 			    P3 * (1-Fl) * unoCTKTMP * unoCTLTMP * sin(2*phiTMP) ;
// 	
//  	 if((decCC2-TMath::Max(-decCT2,-decWT2))<0) return 1e-32;
//     }
//    }
//   }  		     
// //==========================================================================================================================
  
//  if((decCC-TMath::Max(-decCT1,-decWT1))<1e-6) return -1e-6;
//  if((decCC-TMath::Max(-decCT1,-decWT1))<0) return (decCC-TMath::Max(-decCT1,-decWT1));

//   if ( decWT<1e-31 || TMath::IsNaN(decWT) ) decWT = 1e-31;

  double effCValue = effCVal()->getVal();
  if (effCValue<0)  std::cout<<"ERROR! NEGATIVE CT EFFICIENCY SPOTTED AT ("<<ctK<<","<<ctL<<","<<phi<<"): "<<effCValue<<std::endl;
  if (effCValue==0) std::cout<<"ERROR! ZERO CT EFFICIENCY SPOTTED AT ("    <<ctK<<","<<ctL<<","<<phi<<"): "<<effCValue<<std::endl;

  double effWValue = effWVal()->getVal();
  if (effWValue<0)  std::cout<<"ERROR! NEGATIVE WT EFFICIENCY SPOTTED AT ("<<ctK<<","<<ctL<<","<<phi<<"): "<<effWValue<<std::endl;
  if (effWValue==0) std::cout<<"ERROR! ZERO WT EFFICIENCY SPOTTED AT ("    <<ctK<<","<<ctL<<","<<phi<<"): "<<effWValue<<std::endl;
  
//    if ( decCT<0 ){
// //   if ( decCT<1e-32 ){
//     std::cout<<"decCT<0 decWT  = "<<decWT<<" decCT ="<<decCT<<" decCC = "<<decCC<<" decWT1 = "<<decWT1<<" decCT1 = "<<decCT1<<std::endl;
//     decCT = 1e-32;
//    } 
//    if ( decWT<0 && fabs(decWT1)>decCT1 ){
// //   if ( decWT<1e-32 && fabs(decWT1)>decCT1 ){
//     std::cout<<"decWT<0 decWT  = "<<decWT<<" decCT ="<<decCT<<" decCC = "<<decCC<<" decWT1 = "<<decWT1<<" decCT1 = "<<decCT1<<std::endl;
//     decWT = 1e-32;
//   }
  
  double effdecCT=effCValue * decCT/retCT;
  double effdecWT=effWValue * decWT/retWT;
  

  if ( effdecCT<1e-32 ){
   std::cout<<"effdecCT<0 effdecWT  = "<<effdecWT<<" effdecCT ="<<effdecCT<<" decCC = "<<decCC<<" decWT1 = "<<decWT1<<" decCT1 = "<<decCT1<<std::endl;
//   effdecCT = 1e-32;
  } 
  if ( effdecWT<1e-32 && fabs(effdecWT)>effdecCT ){
   std::cout<<"effdecWT<0 effdecWT  = "<<effdecWT<<" effdecCT ="<<effdecCT<<" decCC = "<<decCC<<" decWT1 = "<<decWT1<<" decCT1 = "<<decCT1<<std::endl;
//   effdecWT = 1e-32;
  }
  // std::cout<<"->"<<effCValue<<"*"<<decCT<<" + "<<mFrac<<"*"<<effWValue<<"*"<<decWT<<std::endl;
  double ret = ( effdecCT + mFrac * effdecWT)/( 1 + mFrac );
//  double ret = (9./(32 * 3.14159265) * ( effdecCT + mFrac * effdecWT));
  if (TMath::IsNaN(ret)) {
    std::cout<<"PDFNAN!  effdecWT  = "<<effdecWT<<" effdecCT ="<<effdecCT<< std::endl;
   ret=1e-32;
  }
//   if ( decWT<1e-32 ) {
//     std::cout<<"PDFWarning! Pdf="<<std::scientific<<ret<<" decCT="<<decCT<<" decWT="<<decWT<<" =>setting PDF=1e-32 at:  "<<std::scientific<<ctK<<" "<<ctL<<" "<<phi<<std::endl;
//   
//     ret=1e-32;
//   }
//   if ( decCT<1e-32 ) {
//     std::cout<<"PDFWarning! Pdf="<<std::scientific<<ret<<" decCT="<<decCT<<" decWT="<<decWT<<" =>setting PDF=1e-32 at:  "<<std::scientific<<ctK<<" "<<ctL<<" "<<phi<<std::endl;
//   
//     ret=1e-32;
//   }

  if ( ret<1e-32   ) {
    std::cout<<"\n PDFWarning! Pdf="<<std::scientific<<ret<<" decCT="<<effdecCT<<" decWT="<<effdecWT<<" =>setting PDF=1e-32 at:  "<<std::scientific<<ctK<<" "<<ctL<<" "<<phi<<std::endl;
    std::cout<<"   PDFWarning! Pdf="<<std::scientific<<ret<<" EecCT="<<effdecCT<<" EecWT="<<effdecWT<<" =>setting PDF=1e-32 at:  "<<std::scientific<<ctK<<" "<<ctL<<" "<<phi<<std::endl;
    std::cout<<"PDFWarning! effCValue= "<<std::scientific<<effCValue<<" effWValue = "<<effWValue<<std::endl;
//    ret=1e-32;
  }
  return ret;

}

namespace {
  Bool_t fullRangeCosT(const RooRealProxy& x ,const char* range)
  {
    // set accepted integration range for cosTheta variables
    return range == 0 || strlen(range) == 0
      ? std::fabs(x.min() + 1.) < 1.e-5 && std::fabs(x.max() - 1.) < 1.e-5
      : std::fabs(x.min(range) + 1.) < 1.e-5 && std::fabs(x.max(range) - 1.) < 1.e-5;
  }
  Bool_t fullRangePhi(const RooRealProxy& x ,const char* range)
  {
    
    // set accepted integration range for phi variable
    return range == 0 || strlen(range) == 0
      ? std::fabs(x.min() + TMath::Pi()) < 1.e-3 && std::fabs(x.max() - TMath::Pi()) < 1.e-3
      : std::fabs(x.min(range) + TMath::Pi()) < 1.e-3 && std::fabs(x.max(range) - TMath::Pi()) < 1.e-3;
  }
}

Int_t PdfSigAng::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{
  // use pre-computed integrals for the integration over all the three variables
  // after checking that integrals are in place
  if ( intCPart.size()<1 || intCPart[0]==0 || intWPart.size()<1 || intWPart[0]==0 )
    return 0 ;
  if ( matchArgs(allVars,analVars,ctK,ctL,phi) )
    if ( fullRangeCosT(ctK,rangeName) && fullRangeCosT(ctL,rangeName) && fullRangePhi(phi,rangeName) )
      return 1 ;

  // the lack of analytical integral for the subsets of angular variables does not slow down the fit
  // since only the complete integration is used there
  // if one wants to speed up also the PDF projection for plotting, the other analytical integrals can be computed
  // but it seems a huge effort to me
  return 0 ;

}

Double_t PdfSigAng::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code>0 && code<2) ;
  return 1;

  // use the pre-computed integrals from histogram
  
//  double sqrtFL = sqrt(Fl-Fl*Fl);
  double sqrtFL = sqrt(Fl*(1.-Fl));
//  double sqrtFL = sqrt(Fl)*sqrt(1.-Fl);
  if (TMath::IsNaN(sqrtFL)) sqrtFL=1e-32;
  
  Double_t retCT =  9./(32*3.14159265) * (
					  0.75*(1-Fl)              * intCPart[0]
					  + Fl                     * intCPart[1]
					  + 0.25*(1-Fl)            * intCPart[2]
					  - Fl                     * intCPart[3]
					  + 0.5*P1*(1-Fl)          * intCPart[4]
					  + 0.5*sqrtFL        *P4p * intCPart[5]
					  + sqrtFL        *P5p     * intCPart[6]
					  - sqrtFL        *P6p     * intCPart[7]
					  + 0.5*sqrtFL        *P8p * intCPart[8]
					  + 2*(1-Fl)*P2            * intCPart[9]
					  - P3*(1-Fl)              * intCPart[10]
					  );
  
  Double_t retWT =  9./(32*3.14159265) * (
					  0.75*(1-Fl)              * intWPart[0]
					  + Fl                     * intWPart[1]
					  + 0.25*(1-Fl)            * intWPart[2]
					  - Fl                     * intWPart[3]
					  + 0.5*P1*(1-Fl)          * intWPart[4]
					  + 0.5*sqrtFL        *P4p * intWPart[5]
					  - sqrtFL        *P5p     * intWPart[6]
					  - sqrtFL        *P6p     * intWPart[7]
					  - 0.5*sqrtFL        *P8p * intWPart[8]
					  - 2*(1-Fl)*P2            * intWPart[9]
					  + P3*(1-Fl)              * intWPart[10]
					  );


  if (retCT<=0) {
    if (retCT<0) std::cout<<"ERROR! Negative ct pdf integral, fake value returned"<<std::endl;
    else std::cout<<"ERROR! Null ct pdf integral, fake value returned"<<std::endl;
    return 1e-55;
  }
  if (retWT<=0) {
    if (retWT<0) std::cout<<"ERROR! Negative wt pdf integral, fake value returned"<<std::endl;
    else std::cout<<"ERROR! Null wt pdf integral, fake value returned"<<std::endl;
    return 1e-55;
  }
   if (TMath::IsNaN(retCT)) {
     std::cout<<"ERROR! retCT is NaN !!!"<<std::endl;
     std::cout<<"Fl = "<<Fl<<std::endl;
    retCT=1e-32;
   } 
   if (TMath::IsNaN(retWT)){
     std::cout<<"ERROR! retWT is NaN !!!"<<std::endl;
     std::cout<<"Fl = "<<Fl<<std::endl;
     retWT=1e-32;
   }  

  return (retCT+mFrac*retWT) ;

}
